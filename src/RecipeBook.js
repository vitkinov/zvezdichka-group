import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { BookOpen, User, UtensilsCrossed, FileDown, ExternalLink } from 'lucide-react';
import { parseRecipeMarkdown, generateRecipeMarkdown, generateRecipeFilename, downloadMarkdownFile } from './utils/recipeParser';
import { generateRecipePDF, generateAllRecipesPDF } from './utils/pdfGenerator';
import { recipeFiles } from './recipes/discovered';
import { getMealTypesFromRecipes, getMealTypeLabel, getDefaultMealTypes } from './utils/mealTypes';
import './RecipeBook.css';

const RECIPES_DIR = '/recipes';

function RecipeBook() {
  const [recipes, setRecipes] = useState([]);
  const [mealTypes, setMealTypes] = useState(getDefaultMealTypes());
  const [loading, setLoading] = useState(true);
  const [selectedMealType, setSelectedMealType] = useState('all');
  const [formData, setFormData] = useState({
    title: '',
    mealType: 'breakfast',
    author: '',
    photo: '',
    content: ''
  });

  useEffect(() => {
    loadRecipes();
  }, []);

  const loadRecipes = async () => {
    setLoading(true);
    try {
      // Use the auto-discovered recipe files list
      // This is generated by scripts/discover-recipes.js at build time
      
      // Load each recipe markdown file
      const loadedRecipes = await Promise.all(
        recipeFiles.map(async (filename) => {
          try {
            const response = await fetch(`${RECIPES_DIR}/${filename}`);
            if (!response.ok) {
              console.warn(`Could not load ${filename}`);
              return null;
            }
            const markdown = await response.text();
            const recipe = parseRecipeMarkdown(markdown);
            return {
              id: filename,
              filename: filename,
              ...recipe
            };
          } catch (error) {
            console.error(`Error loading ${filename}:`, error);
            return null;
          }
        })
      );

      // Filter out null values
      const validRecipes = loadedRecipes.filter(recipe => recipe !== null);
      setRecipes(validRecipes);
      
      // Extract meal types dynamically from loaded recipes
      const dynamicMealTypes = getMealTypesFromRecipes(validRecipes);
      if (dynamicMealTypes.length > 0) {
        setMealTypes(dynamicMealTypes);
      }
    } catch (error) {
      console.error('Error loading recipes:', error);
      setRecipes([]);
    } finally {
      setLoading(false);
    }
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    
    if (!formData.title || !formData.author || !formData.content) {
      alert('–ú–æ–ª—è, –ø–æ–ø—ä–ª–Ω–µ—Ç–µ –≤—Å–∏—á–∫–∏ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–∏ –ø–æ–ª–µ—Ç–∞!');
      return;
    }

    const newRecipe = {
      id: Date.now().toString(),
      ...formData
    };

    // Generate markdown content
    const markdownContent = generateRecipeMarkdown(newRecipe);
    const filename = generateRecipeFilename(formData.title);
    
    // Download the markdown file
    downloadMarkdownFile(markdownContent, filename);
    
    // Show success message with instructions
    alert(
      `–†–µ—Ü–µ–ø—Ç–∞—Ç–∞ –µ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∞ –∏ –∏–∑—Ç–µ–≥–ª–µ–Ω–∞!\n\n` +
      `–§–∞–π–ª: ${filename}\n\n` +
      `–ú–æ–ª—è, –ø–æ—Å—Ç–∞–≤–µ—Ç–µ —Ñ–∞–π–ª–∞ –≤ –ø–∞–ø–∫–∞—Ç–∞ public/recipes/ –∏ —Ä–µ—Å—Ç–∞—Ä—Ç–∏—Ä–∞–π—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –∑–∞ –¥–∞ —Å–µ –ø–æ–∫–∞–∂–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ.`
    );
    
    // Reset form
    setFormData({
      title: '',
      mealType: 'breakfast',
      author: '',
      photo: '',
      content: ''
    });
    
    setShowForm(false);
    
    // Auto-refresh recipes after a short delay to allow user to add the file
    setTimeout(() => {
      loadRecipes();
    }, 1000);
  };


  const handleDownloadPDF = async (recipe) => {
    const mealTypeLabel = getMealTypeLabel(recipe.mealType);
    try {
      await generateRecipePDF(recipe, mealTypeLabel);
    } catch (error) {
      console.error('Error generating PDF:', error);
      alert('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ PDF —Ñ–∞–π–ª–∞. –ú–æ–ª—è, –æ–ø–∏—Ç–∞–π—Ç–µ –æ—Ç–Ω–æ–≤–æ.');
    }
  };

  const handleDownloadAllPDF = async () => {
    if (filteredRecipes.length === 0) {
      alert('–ù—è–º–∞ —Ä–µ—Ü–µ–ø—Ç–∏ –∑–∞ –∏–∑—Ç–µ–≥–ª—è–Ω–µ!');
      return;
    }
    try {
      await generateAllRecipesPDF(filteredRecipes, mealTypes);
    } catch (error) {
      console.error('Error generating PDF:', error);
      alert('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ PDF —Ñ–∞–π–ª–∞. –ú–æ–ª—è, –æ–ø–∏—Ç–∞–π—Ç–µ –æ—Ç–Ω–æ–≤–æ.');
    }
  };

  const renderRecipeContent = (content) => {
    const lines = content.split('\n');
    const elements = [];
    let currentList = null;
    let listItems = [];
    let keyIndex = 0;

    const flushList = () => {
      if (currentList && listItems.length > 0) {
        if (currentList.type === 'ul') {
          elements.push(
            <ul key={keyIndex++} className="recipe-text">
              {listItems}
            </ul>
          );
        } else {
          elements.push(
            <ol key={keyIndex++} className="recipe-text">
              {listItems}
            </ol>
          );
        }
        listItems = [];
        currentList = null;
      }
    };

    lines.forEach((line) => {
      const trimmedLine = line.trim();
      
      // Handle markdown headings
      if (trimmedLine.startsWith('## ')) {
        flushList();
        elements.push(<h3 key={keyIndex++} className="recipe-content-h3">{trimmedLine.substring(3)}</h3>);
        return;
      }
      if (trimmedLine.startsWith('### ')) {
        flushList();
        elements.push(<h4 key={keyIndex++} className="recipe-content-h4">{trimmedLine.substring(4)}</h4>);
        return;
      }
      if (trimmedLine.startsWith('# ')) {
        flushList();
        elements.push(<h2 key={keyIndex++} className="recipe-content-h2">{trimmedLine.substring(2)}</h2>);
        return;
      }
      
      // Handle bullet lists
      if (trimmedLine.startsWith('- ') || trimmedLine.startsWith('* ')) {
        if (currentList?.type !== 'ul') {
          flushList();
          currentList = { type: 'ul' };
        }
        listItems.push(<li key={keyIndex++} className="recipe-content-li">{trimmedLine.substring(2)}</li>);
        return;
      }
      
      // Handle numbered lists
      const numberedMatch = trimmedLine.match(/^\d+\.\s+(.+)$/);
      if (numberedMatch) {
        if (currentList?.type !== 'ol') {
          flushList();
          currentList = { type: 'ol' };
        }
        listItems.push(<li key={keyIndex++} className="recipe-content-li">{numberedMatch[1]}</li>);
        return;
      }
      
      // Non-list line - flush any current list
      flushList();
      
      // Handle bold text (**text**)
      if (trimmedLine.includes('**')) {
        const parts = trimmedLine.split(/(\*\*.*?\*\*)/g);
        elements.push(
          <p key={keyIndex++}>
            {parts.map((part, partIndex) => {
              if (part.startsWith('**') && part.endsWith('**')) {
                return <strong key={partIndex}>{part.slice(2, -2)}</strong>;
              }
              return <span key={partIndex}>{part}</span>;
            })}
          </p>
        );
        return;
      }
      
      // Regular paragraph
      if (trimmedLine) {
        elements.push(<p key={keyIndex++}>{trimmedLine}</p>);
        return;
      }
      
      // Empty line
      elements.push(<br key={keyIndex++} />);
    });

    // Flush any remaining list
    flushList();

    return elements;
  };

  const filteredRecipes = recipes.filter(recipe => {
    if (selectedMealType === 'all') {
      return true;
    }
    return recipe.mealType === selectedMealType;
  });

  return (
    <div className="recipe-book">
      <div className="recipe-book-header">
        <div className="recipe-book-title-section">
          <BookOpen size={32} />
          <div>
            <h2>–ö–Ω–∏–≥–∞ —Å—ä—Å –∑–¥—Ä–∞–≤–æ—Å–ª–æ–≤–Ω–∏ —Ä–µ—Ü–µ–ø—Ç–∏</h2>
          </div>
        </div>
        <div className="recipe-book-actions">
          {!loading && filteredRecipes.length > 0 && (
            <button 
              className="btn-download-all"
              onClick={handleDownloadAllPDF}
              title="–ò–∑—Ç–µ–≥–ª–∏ –≤—Å–∏—á–∫–∏ —Ä–µ—Ü–µ–ø—Ç–∏ –∫–∞—Ç–æ PDF"
            >
              <FileDown size={20} />
              –ò–∑—Ç–µ–≥–ª–∏ –≤—Å–∏—á–∫–∏ PDF
            </button>
          )}
        </div>
      </div>

      {loading && (
        <div className="loading">
          <div className="spinner"></div>
          <p>–ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Ä–µ—Ü–µ–ø—Ç–∏...</p>
        </div>
      )}

      {!loading && recipes.length > 0 && (
        <div className="recipe-filter">
          <div className="filter-label">
            <UtensilsCrossed size={18} />
            <span>–§–∏–ª—Ç—Ä–∏—Ä–∞–π –ø–æ —Ç–∏–ø:</span>
          </div>
          <div className="filter-buttons">
            <button
              className={`filter-btn ${selectedMealType === 'all' ? 'active' : ''}`}
              onClick={() => setSelectedMealType('all')}
            >
              –í—Å–∏—á–∫–∏
            </button>
            {mealTypes.map(type => (
              <button
                key={type.value}
                className={`filter-btn ${selectedMealType === type.value ? 'active' : ''}`}
                onClick={() => setSelectedMealType(type.value)}
              >
                {type.label}
              </button>
            ))}
          </div>
          {filteredRecipes.length !== recipes.length && (
            <div className="filter-results-count">
              –ü–æ–∫–∞–∑–∞–Ω–∏: {filteredRecipes.length} –æ—Ç {recipes.length} —Ä–µ—Ü–µ–ø—Ç–∏
            </div>
          )}
        </div>
      )}

      {!loading && filteredRecipes.length > 0 && (
        <div className="recipes-container">
          <div className="recipes-grid">
            {filteredRecipes.map((recipe) => (
              <Link 
                key={recipe.id} 
                to={`/recipes/${encodeURIComponent(recipe.filename)}`}
                className="recipe-card-link"
              >
                <div className="recipe-card">
                  {recipe.photo && (
                    <div className="recipe-photo">
                      <img src={recipe.photo} alt={recipe.title} />
                    </div>
                  )}
                  <div className="recipe-content">
                    <div className="recipe-header">
                      <h3 className="recipe-title">{recipe.title}</h3>
                      <ExternalLink size={18} className="recipe-link-icon" />
                    </div>
                    <div className="recipe-meta">
                      <span className="recipe-meal-type">
                        <UtensilsCrossed size={14} />
                        {getMealTypeLabel(recipe.mealType)}
                      </span>
                      <span className="recipe-author">
                        <User size={14} />
                        {recipe.author}
                      </span>
                    </div>
                    <div className="recipe-preview">
                      {recipe.content && (() => {
                        // Get first meaningful line (not empty, not heading, not list item)
                        const lines = recipe.content.split('\n');
                        const firstLine = lines.find(line => {
                          const trimmed = line.trim();
                          return trimmed && 
                                 !trimmed.startsWith('#') && 
                                 !trimmed.startsWith('-') && 
                                 !trimmed.startsWith('*') &&
                                 !trimmed.match(/^\d+\./);
                        });
                        const preview = firstLine ? firstLine.trim() : recipe.content.trim();
                        const displayText = preview.length > 150 ? preview.substring(0, 150) + '...' : preview;
                        return (
                          <p className="recipe-preview-text">{displayText}</p>
                        );
                      })()}
                    </div>
                  </div>
                </div>
              </Link>
            ))}
          </div>
        </div>
      )}

      {!loading && filteredRecipes.length === 0 && recipes.length > 0 && (
        <div className="no-recipes">
          <div className="no-recipes-icon">üîç</div>
          <h3>–ù—è–º–∞ —Ä–µ—Ü–µ–ø—Ç–∏ —Å –∏–∑–±—Ä–∞–Ω–∏—è —Ñ–∏–ª—Ç—ä—Ä</h3>
          <p>–ú–æ–ª—è, –∏–∑–±–µ—Ä–µ—Ç–µ –¥—Ä—É–≥ —Ç–∏–ø —è—Å—Ç–∏–µ –∏–ª–∏ –∫–ª–∏–∫–Ω–µ—Ç–µ "–í—Å–∏—á–∫–∏" –∑–∞ –¥–∞ –≤–∏–¥–∏—Ç–µ –≤—Å–∏—á–∫–∏ —Ä–µ—Ü–µ–ø—Ç–∏.</p>
        </div>
      )}

      {!loading && recipes.length === 0 && (
        <div className="no-recipes">
          <div className="no-recipes-icon">üìñ</div>
          <h3>–ù—è–º–∞ –¥–æ–±–∞–≤–µ–Ω–∏ —Ä–µ—Ü–µ–ø—Ç–∏</h3>
          <p>–î–æ–±–∞–≤–µ—Ç–µ –ø—ä—Ä–≤–∞—Ç–∞ —Ä–µ—Ü–µ–ø—Ç–∞, –∑–∞ –¥–∞ –∑–∞–ø–æ—á–Ω–µ—Ç–µ –∫–Ω–∏–≥–∞—Ç–∞ —Å—ä—Å –∑–¥—Ä–∞–≤–æ—Å–ª–æ–≤–Ω–∏ —Ä–µ—Ü–µ–ø—Ç–∏!</p>
          <p style={{ marginTop: '10px', fontSize: '0.9rem', color: 'var(--text-secondary)' }}>
            –†–µ—Ü–µ–ø—Ç–∏—Ç–µ —Å–µ –∑–∞—Ä–µ–∂–¥–∞—Ç –æ—Ç Markdown —Ñ–∞–π–ª–æ–≤–µ –≤ –ø–∞–ø–∫–∞—Ç–∞ <code>public/recipes/</code>
          </p>
        </div>
      )}
    </div>
  );
}

export default RecipeBook;

