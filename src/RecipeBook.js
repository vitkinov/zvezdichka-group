import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { BookOpen, User, UtensilsCrossed, FileDown, ExternalLink } from 'lucide-react';
import { parseRecipeMarkdown } from './utils/recipeParser';
import { generateAllRecipesPDF } from './utils/pdfGenerator';
import { recipeFiles } from './recipes/discovered';
import { getMealTypesFromRecipes, getMealTypeLabel, getDefaultMealTypes, MEAL_TYPE_LABELS } from './utils/mealTypes';
import { getRecipeImage } from './utils/recipeImage';
import './RecipeBook.css';

const RECIPES_DIR = '/recipes';

function RecipeBook() {
  const [recipes, setRecipes] = useState([]);
  const [mealTypes, setMealTypes] = useState(getDefaultMealTypes());
  const [loading, setLoading] = useState(true);
  const [selectedMealType, setSelectedMealType] = useState('all');

  useEffect(() => {
    loadRecipes();
  }, []);

  const loadRecipes = async () => {
    setLoading(true);
    try {
      // Use the auto-discovered recipe files list
      // This is generated by scripts/discover-recipes.js at build time
      
      // Load each recipe markdown file
      const loadedRecipes = await Promise.all(
        recipeFiles.map(async (filename) => {
          try {
            const response = await fetch(`${RECIPES_DIR}/${filename}`);
            if (!response.ok) {
              console.warn(`Could not load ${filename}`);
              return null;
            }
            const markdown = await response.text();
            const recipe = parseRecipeMarkdown(markdown);
            return {
              id: filename,
              filename: filename,
              ...recipe
            };
          } catch (error) {
            console.error(`Error loading ${filename}:`, error);
            return null;
          }
        })
      );

      // Filter out null values
      const validRecipes = loadedRecipes.filter(recipe => recipe !== null);
      setRecipes(validRecipes);
      
      // Extract meal types dynamically from loaded recipes
      const dynamicMealTypes = getMealTypesFromRecipes(validRecipes);
      if (dynamicMealTypes.length > 0) {
        setMealTypes(dynamicMealTypes);
      }
    } catch (error) {
      console.error('Error loading recipes:', error);
      setRecipes([]);
    } finally {
      setLoading(false);
    }
  };

  const handleDownloadAllPDF = async () => {
    if (filteredRecipes.length === 0) {
      alert('–ù—è–º–∞ —Ä–µ—Ü–µ–ø—Ç–∏ –∑–∞ –∏–∑—Ç–µ–≥–ª—è–Ω–µ!');
      return;
    }
    try {
      await generateAllRecipesPDF(filteredRecipes, mealTypes);
    } catch (error) {
      console.error('Error generating PDF:', error);
      alert('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ PDF —Ñ–∞–π–ª–∞. –ú–æ–ª—è, –æ–ø–∏—Ç–∞–π—Ç–µ –æ—Ç–Ω–æ–≤–æ.');
    }
  };

  const stripMarkdown = (text) => {
    if (!text) return '';
    // Remove markdown formatting
    return text
      .replace(/\*\*(.*?)\*\*/g, '$1') // Bold **text**
      .replace(/\*(.*?)\*/g, '$1') // Italic *text*
      .replace(/##+ /g, '') // Headings ##
      .replace(/`(.*?)`/g, '$1') // Inline code `code`
      .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1') // Links [text](url)
      .trim();
  };

  const filteredRecipes = recipes
    .filter(recipe => {
      if (selectedMealType === 'all') {
        return true;
      }
      return recipe.mealType === selectedMealType;
    })
    .sort((a, b) => {
      // First sort by mealType according to MEAL_TYPE_LABELS order
      const mealTypeOrder = Object.keys(MEAL_TYPE_LABELS);
      const indexA = mealTypeOrder.indexOf(a.mealType || '');
      const indexB = mealTypeOrder.indexOf(b.mealType || '');
      
      if (indexA !== indexB) {
        // If both are in MEAL_TYPE_LABELS, sort by index
        if (indexA !== -1 && indexB !== -1) {
          return indexA - indexB;
        }
        // If only one is in MEAL_TYPE_LABELS, it comes first
        if (indexA !== -1) return -1;
        if (indexB !== -1) return 1;
        // If neither is in MEAL_TYPE_LABELS, sort alphabetically
        const mealTypeA = (a.mealType || '').toLowerCase();
        const mealTypeB = (b.mealType || '').toLowerCase();
        return mealTypeA.localeCompare(mealTypeB);
      }
      
      // If same mealType, sort by title (ascending)
      const titleA = (a.title || '').toLowerCase();
      const titleB = (b.title || '').toLowerCase();
      return titleA.localeCompare(titleB);
    });

  return (
    <div className="recipe-book">
      <div className="recipe-book-header">
        <div className="recipe-book-title-section">
          <BookOpen size={32} />
          <div>
            <h2>–ö–Ω–∏–≥–∞ —Å—ä—Å –∑–¥—Ä–∞–≤–æ—Å–ª–æ–≤–Ω–∏ —Ä–µ—Ü–µ–ø—Ç–∏</h2>
          </div>
        </div>
        <div className="recipe-book-actions">
          {!loading && filteredRecipes.length > 0 && (
            <button 
              className="btn-download-all"
              onClick={handleDownloadAllPDF}
              title="–ò–∑—Ç–µ–≥–ª–∏ –≤—Å–∏—á–∫–∏ —Ä–µ—Ü–µ–ø—Ç–∏ –∫–∞—Ç–æ PDF"
            >
              <FileDown size={20} />
              –ò–∑—Ç–µ–≥–ª–∏ –≤—Å–∏—á–∫–∏ PDF
            </button>
          )}
        </div>
      </div>

      {loading && (
        <div className="loading">
          <div className="spinner"></div>
          <p>–ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Ä–µ—Ü–µ–ø—Ç–∏...</p>
        </div>
      )}

      {!loading && recipes.length > 0 && (
        <div className="recipe-filter">
          <div className="filter-label">
            <UtensilsCrossed size={18} />
            <span>–§–∏–ª—Ç—Ä–∏—Ä–∞–π –ø–æ —Ç–∏–ø:</span>
          </div>
          <div className="filter-buttons">
            <button
              className={`filter-btn ${selectedMealType === 'all' ? 'active' : ''}`}
              onClick={() => setSelectedMealType('all')}
            >
              –í—Å–∏—á–∫–∏
            </button>
            {mealTypes.map(type => (
              <button
                key={type.value}
                className={`filter-btn ${selectedMealType === type.value ? 'active' : ''}`}
                onClick={() => setSelectedMealType(type.value)}
              >
                {type.label}
              </button>
            ))}
          </div>
          {filteredRecipes.length !== recipes.length && (
            <div className="filter-results-count">
              –ü–æ–∫–∞–∑–∞–Ω–∏: {filteredRecipes.length} –æ—Ç {recipes.length} —Ä–µ—Ü–µ–ø—Ç–∏
            </div>
          )}
        </div>
      )}

      {!loading && filteredRecipes.length > 0 && (
        <div className="recipes-container">
          <div className="recipes-grid">
            {filteredRecipes.map((recipe) => (
              <Link 
                key={recipe.id} 
                to={`/recipes/${encodeURIComponent(recipe.filename)}`}
                className="recipe-card-link"
              >
                <div className="recipe-card">
                  <div className="recipe-photo">
                    <img src={getRecipeImage(recipe.photo, recipe.title)} alt={recipe.title} />
                  </div>
                  <div className="recipe-content">
                    <div className="recipe-header">
                      <h3 className="recipe-title">{recipe.title}</h3>
                      <ExternalLink size={18} className="recipe-link-icon" />
                    </div>
                    <div className="recipe-meta">
                      <span className="recipe-meal-type">
                        <UtensilsCrossed size={14} />
                        {getMealTypeLabel(recipe.mealType)}
                      </span>
                      <span className="recipe-author">
                        <User size={14} />
                        {recipe.author}
                      </span>
                    </div>
                    <div className="recipe-preview">
                      {recipe.content && (() => {
                        // Get first meaningful line (not empty, not heading, not list item)
                        const lines = recipe.content.split('\n');
                        const firstLine = lines.find(line => {
                          const trimmed = line.trim();
                          return trimmed && 
                                 !trimmed.startsWith('#') && 
                                 !trimmed.startsWith('-') && 
                                 !trimmed.startsWith('*') &&
                                 !trimmed.match(/^\d+\./);
                        });
                        const preview = firstLine ? firstLine.trim() : recipe.content.trim();
                        const strippedPreview = stripMarkdown(preview);
                        const displayText = strippedPreview.length > 150 ? strippedPreview.substring(0, 150) + '...' : strippedPreview;
                        return (
                          <p className="recipe-preview-text">{displayText}</p>
                        );
                      })()}
                    </div>
                  </div>
                </div>
              </Link>
            ))}
          </div>
        </div>
      )}

      {!loading && filteredRecipes.length === 0 && recipes.length > 0 && (
        <div className="no-recipes">
          <div className="no-recipes-icon">üîç</div>
          <h3>–ù—è–º–∞ —Ä–µ—Ü–µ–ø—Ç–∏ —Å –∏–∑–±—Ä–∞–Ω–∏—è —Ñ–∏–ª—Ç—ä—Ä</h3>
          <p>–ú–æ–ª—è, –∏–∑–±–µ—Ä–µ—Ç–µ –¥—Ä—É–≥ —Ç–∏–ø —è—Å—Ç–∏–µ –∏–ª–∏ –∫–ª–∏–∫–Ω–µ—Ç–µ "–í—Å–∏—á–∫–∏" –∑–∞ –¥–∞ –≤–∏–¥–∏—Ç–µ –≤—Å–∏—á–∫–∏ —Ä–µ—Ü–µ–ø—Ç–∏.</p>
        </div>
      )}

      {!loading && recipes.length === 0 && (
        <div className="no-recipes">
          <div className="no-recipes-icon">üìñ</div>
          <h3>–ù—è–º–∞ –¥–æ–±–∞–≤–µ–Ω–∏ —Ä–µ—Ü–µ–ø—Ç–∏</h3>
          <p>–î–æ–±–∞–≤–µ—Ç–µ –ø—ä—Ä–≤–∞—Ç–∞ —Ä–µ—Ü–µ–ø—Ç–∞, –∑–∞ –¥–∞ –∑–∞–ø–æ—á–Ω–µ—Ç–µ –∫–Ω–∏–≥–∞—Ç–∞ —Å—ä—Å –∑–¥—Ä–∞–≤–æ—Å–ª–æ–≤–Ω–∏ —Ä–µ—Ü–µ–ø—Ç–∏!</p>
          <p style={{ marginTop: '10px', fontSize: '0.9rem', color: 'var(--text-secondary)' }}>
            –†–µ—Ü–µ–ø—Ç–∏—Ç–µ —Å–µ –∑–∞—Ä–µ–∂–¥–∞—Ç –æ—Ç Markdown —Ñ–∞–π–ª–æ–≤–µ –≤ –ø–∞–ø–∫–∞—Ç–∞ <code>public/recipes/</code>
          </p>
        </div>
      )}
    </div>
  );
}

export default RecipeBook;

